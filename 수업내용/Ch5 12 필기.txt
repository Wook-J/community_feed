DB 커넥션 스레드 풀

애플리케이션 -> DB 요청을 위한 연결하는 것은 큰 비용이 드는 직업

그렇기 때문에 미리 연결을 만들어 두고 관리하는 방법으로 연결을 재사용함!
--> DB Connection Pool

애플리케이션을 실행할 때 미리 이 풀에 몇개의 스레드가 있을 지를 설정할 수 있음
- 스프링 기준으로 10개 있고, 이를 설정하는 옵션을 max connection pool 이라고 함!

DataSource 인터페이스를 이용하여 커넥션 풀 관리
2.0 이후부터는 HikariCP 라이브러리가 기본 옵션

스프링에서는 이런 스레드 풀을 데이터소스라는 인터페이스를 통해 표준화 시켜주었음!
(기존에는 Tomcat JDBC를 사용)

----------------------------------------------------------------------------------------------
DB 작업 요청이 들어왔다면?
DBCP에 스레드가 하나도 없는 데, 즉 빈 스레드 풀에 요청이 계속 오는 경우?
-> 요청은 계속해서 대기하게 됨....!!
-> 그러다가 데이터소스에서 지정해둔 타임아웃 시간이 지나게 되면 타임아웃 에러를 반환
--> 그럼 스레드 풀을 그냥 최대로 채우면 되는거 아님?

- 무조건 많다고 성능이 오르는건 아님! (컨텍스트 스위칭 때문! -> 이게 뭐지..?)
-> DB가 처리할 수 있는 스레드 숫자는 제한되어 있음(cpu 코어 개수 * 2 + 저장 매체에 따른 개수 차이)
-> 오히려 잦은 컨텍스트 스위칭으로 인해 성능이 떨어짐..!

if 100만 개 요청을 거의 동시에 DB에 보내는 경우
-> DB에서는 이 요청들을 동시에 처리하는 것이 아닌 굉장히 빠르게 CPU가 작업들을 스케쥴링에 따라 1개씩 처리함!

한 스레드에서 작업을 하다 다른 스레드에서 작업을 계속 바꾸는 컨텍스트 스위칭으로 오히려 병목지점이 됨...!
- 라이브러리에서 공식적으로 제안하는 스레드 수 : DB CPU의 코어개수 * 2 + 저장매체에 따른 개수 차이
(저장매체는 DB에서 HDD나 SSD 차이에 따라 좀더 빨리 수행될수록 몇개를 더추가하는 것을 권장)

- 실무에서는 스레드풀 설정 후에 꼭 한번 부하테스트를 같이 진행하는 것을 추천함!
(NGrinder를 이용)

----------------------------------------------------------------------------------------------
쓰레드 풀을 빠르게 반환하게 하려면 트랜젝션을 작게 잡는 것도 중요!!
(Open-in-view 옵션을 켜두면 Controller 반환때까지 커넥션을 반환하지 않음)

상단에 OSIV(Open Session In View) 옵션이 켜져 있으면 영속성 컨텍스트가 더 오래 지속됨
-> 커넥션을 반환하는 시간도 더 길어짐
-> 다만 장점으로는 뷰템플릿이나 API 컨트롤러에서도 지연로딩이 가능해짐
-> 만약 성능이 크게 상관이 없고 뷰 템플릿을 이용해서 빠르게 개발을 해야하는 Admin Service같은 경우에는 
    오히려 OSIV 옵션을 켜두는게 개발이 도움이 될수 있음

지연로딩 : JPA에서 엔티티 간 관계를 조회할 때, 연관된 엔티티를 처음부터 즉시 로딩하지 않고, 실제로 사용할 때 로딩하는 전략
- 장점 : 초기 성능 최적화
- 단점 : 예상치 못한 시점에 쿼리 발생(-> 성능저하 가능성)
- 실무 대응 : fetch join, DTO 분리, Entity Graph 등으로 최적화