JWT, 인증과 인가, Oauth 개념

JWT (Json Web Token) : 서버와 클라이언트 사이 통신에서 사용되는 Json 형태의 웹토큰
- 서버의 확정성이 높고, 특정 DB나 서버에 의존하지 않아도 됨
  (현재 MSA나 클라우드 환경이 주를 이루고 있는 요즘 웹환경에서 환영받고 있음)

JWT 구성 : 헤더, 페이로드, 시그니처(aaaa.bbbbb.ccccc)
- 헤더 : 토큰유형, 서명에 사용된 해시 알고리즘 SHA 256 같은 것 포함
	{
	  "alg": "HS256",       // 서명 알고리즘 (ex: HMAC SHA-256)
	  "typ": "JWT"          // 토큰 타입
	}
- 페이로드 : 일반적으로 사용자에 대한 데이터(사용자 ID, 만료시간, 역할 등 포함)
	{
	  "sub": "1234567890",     // subject (예: 사용자 ID)
	  "name": "John Doe",      // 사용자 이름
	  "admin": true,           // 커스텀 클레임도 가능
	  "exp": 1716390000        // 만료 시간 (timestamp)
	}
- 시그니처 : 토큰의 무결성과 인증을 보장하는 암호화된 서명(인코딩된 헤더, 페이로드, 비밀키 결합)
	HMACSHA256(
	  base64UrlEncode(header) + "." + base64UrlEncode(payload),
	  secret
	)
--------------------------------------------------------------------------------------------------
JWT 인증 방식
1. 사용자가 로그인하면 서버에서는 JWT 값을 반환
2. 전송된 JWT를 주로 로컬스토리지나 쿠키에 저장
3. 이후 서버로 요청할 때에 클라이언트에서 Header에 담아서 보냄(Authorization)
4. 토큰을 받은 서버는 서명을 확인하고 내용을 파싱해서 데이터를 사용함.

이후 추가적으로 토큰이 만료된다면 refresh token을 이용해서 새로운 토큰 발급

-> 각 개별 서버에서는 따로 세션이나 쿠키처럼 서버 자체에서 값을 불러오는 대신
    매번 요청이 오는 토큰을 파싱을 해서 토큰 안에 있는 정보만 사용하면 됨!

-> 이중화된 서버에서도 같은 토큰을 쓴다면 같은 유저에 대한 요청으로 확인할 수 있게 됨! (확장성 높음!)

전체적으로 JWT는 현재 클라우드 환경에서 서버 다중화가 필수가 된 지금은 피할 수 없는 선택지로 자리잡고 있음..!
--------------------------------------------------------------------------------------------------
인증과 인가의 차이
- 인증 : 사용자를 식별하는 프로세스/ 인가 : 권한을 확인하는 프로세스
- 인증은 로그인 같은 사용자를 확인하는 과정인 것에 반해/ 인가는 유저가 이 API를 사용할 수 있는 권한을 의미함!
-> JWT 에 User의 id와 권한을 Role base로 추가해 admin과 일반 유저를 구분할 수 있음!
--------------------------------------------------------------------------------------------------
Oauth : third-party 애플리케이션에 유저의 정보에 접근할 수 있게 하는 표준 프로토콜
  (흔히 앱이나 게임에서 볼 수 있는 SNS 로그인 연동이 대표적!)
  (소셜 프로필과 이름 등 유저의 정보를 제공해서 서드 파티에서도 유용하게 사용할 수 있게됨)
-> 단 비밀번호와 같은 것을 공유하지 않고 제한된 정보를 제공하게 함!
-> 그런데 해커 같은 제3자가 정보를 요구하면 Oauth는 어떻게 막을 수 있을까?

Oauth 동작 방식
1. Resource Owner - 데이터를 가지고 있는 유저(페북이나 구글 이런 정보를 제공하는 플랫폼을 이용하는 사용자)
2. Client - 데이터 접근을 하려는 third-party 애플리케이션
3. Authorization & Resource Server (토큰을 만들고 데이터를 제공하는 서버)
(ex 구글 로그인을 연동한다고 생각하면 구글 플랫폼이 Authorization & Resource Server임)

ex 구글 로그인 연동
1. 사용자(Resource Owner)가 구글 소셜 로그인 요청을 함
2. 연동하는 서비스(Client)에서는 구글 플랫폼에 "이 유저가 로그인 요청을 원해"라는 정보를 구글에 보냄
  (클라이언트는 [내가 기존에 구글에 연동하면서 받았던 클라이언트 아이디]와 [유저가 로그인이후에 돌아가야할 Redirect URL],
   [이 요청을 클라이언트가 부여받은 리소스 접근권한인 scope]까지 포함해서 요청을 함)
3. 구글에서는 사용자 아이디와 PW를 입력할 수 있는 페이지를 반환하게 됨
  - 여기에서 소셜 로그인 창이 열리게 되면 이후 유저는 아이디와 PW를 입력을 하고 구글에 전달
4. 유저가 아이디 PW를 입력하면 구글 쪽에서는 유효성을 확인하고 유저에게 Authorization 코드와 처음 클라이언트가 구글에게
  전달했던 Redirect URL로 이동시키게 됨
  - 리다이렉트된 클라이언트 주소에서 아까 위에서 받은 코드와 미리 발급받은 클라이언트 아이디, 클라이언트 시크릿을 통해 
    정말 인증이 필요한 Access Token을 받을 수 있게 됨
5. 클라이언트는 Access Token을 통해 구글 플랫폼에 유저에 대한 정보를 요청하고 관련된 정보들을 받아올 수 있게 됨!

(우리가 만든 서비스에서 구글 로그인을 띄워주고 유저는 로그인을 하게되면
 Redirect URL로 Authorization 코드와 함께 이동이 되고,
 우리가 만든 서비스는 마지막으로 이 코드를 가지고 구글에 토큰을 요청하는 방식임
 이 토큰은 JWT 토큰으로 요청을 할 때 헤더에 같이 보내서 유저의 정보를 받아볼 수 있게 됨)

--------------------------------------------------------------------------------------------------
질문과 과제
1. JWT를 로컬 스토리지, 쿠키에 저장하는 방법이 있다고 했는데, 각 저장할 때의 장단점
2. Oauth 3번째 단계에서 Access Code를 주는 것 대신 Access Token과 Redirect를 바로하면 안될까??

